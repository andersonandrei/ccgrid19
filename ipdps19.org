# -*- mode: org -*-
# -*- coding: utf-8 -*-
#+STARTUP: overview indent inlineimages logdrawer

#+TITLE: A Design of Experiments Approach to Autotuning under Tight Budget Constraints
#+LANGUAGE:    en
#+TAGS: noexport(n) Stats(S)
#+TAGS: Teaching(T) R(R) OrgMode(O) Python(P)
#+TAGS: Book(b) DOE(D) Code(C) NODAL(N) FPGA(F) Autotuning(A) Arnaud(r)
#+TAGS: DataVis(v) PaperReview(W)
#+EXPORT_SELECT_TAGS: Blog
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+COLUMNS: %25ITEM %TODO %3PRIORITY %TAGS
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w@) APPT(a!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

#+LATEX_CLASS: org-ieeetran
#+LATEX_CLASS_OPTIONS: [conference]
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{url}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: %\usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[english]{babel}
#+LATEX_HEADER: \usepackage{multirow}
#+LATEX_HEADER: \usepackage{caption}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{array}
#+LATEX_HEADER: \usepackage{relsize}
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_HEADER: \usepackage{wasysym}
#+LATEX_HEADER: \usepackage{ragged2e}

#+LATEX_HEADER: \graphicspath{{./img/}}
#+LATEX_HEADER: \renewcommand*{\UrlFont}{\ttfamily\smaller\relax}

#+LATEX_HEADER: \author{\IEEEauthorblockN{Pedro Bruel\IEEEauthorrefmark{1}\IEEEauthorrefmark{2},
#+LATEX_HEADER: Arnaud Legrand\IEEEauthorrefmark{1},
#+LATEX_HEADER: Brice Videau\IEEEauthorrefmark{1} and
#+LATEX_HEADER: Alfredo Goldman\IEEEauthorrefmark{2}}
#+LATEX_HEADER: \IEEEauthorblockA{\IEEEauthorrefmark{1}University of Grenoble Alpes, CNRS, INRIA, LIG - Grenoble, France\\
#+LATEX_HEADER: Email: \{arnaud.legrand, brice.videau\}@imag.fr}
#+LATEX_HEADER: \IEEEauthorblockA{\IEEEauthorrefmark{2}University of São Paulo - São Paulo, Brazil\\
#+LATEX_HEADER: Email: \{phrb, gold\}@ime.usp.br}}

#+LATEX: \begin{abstract}
Abstract
#+LATEX: \end{abstract}

* Arnaud's Draft                                                   :noexport:
** Intro
** Context
- HPC, optimizing code is a nightmare although very important gains
  can be expected when one can afford an expert to work on it.
- Typical techniques are source-to-source transformation + compiler
  flag optimization
- Even when automatic, this optimization can be very time consumming
  (costly experiments + curse of dimensionality).
** Related Work
*** Source-to-source transformation
*** Auto-tuning frameworks
*** Exploration Strategies
** Statement
- Generic Meta-Heuristics (GAs, Simulated Annealing, Tabu Search) do
  not exploit well specific properties of the problem and require very
  large amount of measurements.
- Classical Mathematical Optimization techniques (gradient, surrogate,
  ...) are ineffective in this context as the geometry is far more
  complicated than what can be found in maths textbooks
- Fully automatic ML make sense to model and predict important factors
  but typically require a large amount of data to be effective as the
  class of underlying models is generally very large.
- In many settings a naive uniform random sampling strategy works just
  as well as other methods.
- None of the above methods really brings exploitable knowledge
  allowing to decide whether further exploration may be useful.
** Proposal
Sequential approach, using D-optimal designs. Requires a model
(ideally provided by an expert) which is iteratively refined.
*** D-optimal designs in a nutshell
- Explanations of DoE + Simple illustration
- Analysis strategy (aov, lm)
- Allows a global overview and to detect the main factors right away
  to focus on the most promising parts of the subspace
- This assumes that there is a global geometry of the problem that can
  be exploited despite the roughness of the local geometry. This
  assumption may be wrong but is likely to go detected.
*** General Method in the context of auto-tuning
Ideally, human in the loop but for the sake of a general performance
evaluation, we had to automate it.
** Performance Evaluation
*** Experimental Methodology
G5K, database, RR, R + julia +...
*** Working out a simple example in details: a Laplacian Kernel
Laplacian Kernel on a GPU + BOAST
*** Evaluation on the ??? benchmark suite
ORIO
** Conclusion and Future Work
- DoE based strategy
- Revealed impressively effective for the Laplacian kernel.
- Not as impressive on the other benchmarks but despite their general
  use, it apears that little gain can be expected. In any cases, our
  approach produces at least as good results with far fewer measurements.
- Future work:
  - Other benchmarks
  - source-to-source + compiler flags
  - connexion with online learning

* Introduction
Optimizing code for objectives such as performance and power consumption is
fundamental to the success and cost effectiveness of industrial and scientific
endeavors in High Performance Computing. A considerable amount of highly
specialized time and effort is spent in porting and optimizing code for GPUs,
FPGAs and other hardware accelerators. Experts are also needed to leverage
bleeding edge software improvements in compilers, languages, libraries and
frameworks. The automatic configuration and optimization of High Performance
Computing applications, or /autotuning/, is a technique effective in decreasing
the cost and time needed to adopt efficient hardware and software. Typical
targets for autotuning include algorithm selection, source-to-source
transformations and compiler configuration.

Autotuning can be studied as a search problem, where the objective is to
minimize single or multiple software of hardware metrics. The exploration of the
search spaces defined by configurations and optimizations present interesting
challenges to search strategies. These search spaces grow exponentially with the
number of considered configuration parameters and their possible values. They
are also difficult to extensively explore due to the often prohibitive costs of
hardware utilization and program compilation and execution times. Developing
autotuning strategies capable of producing good optimizations while minimizing
resource utilization is therefore essential. The capability of acquiring
knowledge about an optimization problem is also a desired feature of an
autotuning strategy, since this knowledge can decrease the cost of subsequent
optimizations of the same application or for the same hardware.

It is common and usually effective to use search meta-heuristics such as genetic
algorithms and simulated annealing in autotuning. These strategies usually
attempt to exploit local properties and are not capable of fully exploiting
global search space structures. They are also not much more effective in
comparison with a naive uniform random sample of the search
space\nbsp{}\cite{seymour2008comparison,knijnenburg2003combined}, and usually rely on a
large number of measurements and frequent restarts to achieve good performance
improvements. Search strategies based on gradient descent also are commonly used
in autotuning and rely on a large number of measurements. Their effectiveness
diminishes additionally in search spaces with complex local structures.
Completely automated machine learning autotuning strategies are effective in
building models for predicting important optimization parameters, but still rely
on a sizable data set for training. Large data sets are fundamental to
strategies based on machine learning since they select models from a generally
very large class.

Search strategies based on meta-heuristics, gradient descent and machine
learning require a large number of measurements to be effective, and are usually
incapable of providing knowledge about search spaces to users. At the end of
each autotuning session it is difficult to decide if and where further
exploration is warranted, and impossible to know which parameters are
responsible for the observed improvements. After exploring a search space, it is
impossible to confidently deduce its global properties since its was explored
with unknown biases.

In this paper we propose an autotuning strategy that leverages existing expert
and approximate knowledge about a problem in the form of a performance model,
and refines this initial model iteratively using empirical performance
evaluations, statistical analysis and user input. Our strategy puts a heavy
weight on decreasing the costs of autotuning by using efficient Design of
Experiments strategies to minimize the number of experiments needed to find good
optimizations. Each optimization iteration uses /Analysis of Variance/ (ANOVA)
to help identify the relative significance of each configurable parameter to the
performance observations. An architecture- and problem-specific performance
model is built iteratively and with user input, enabling informed decisions on
which regions of the search space are worth exploring.

We present the performance of our approach on a Laplacian Kernel for GPUs where
the search space, global optimum and performance model approximation are known.
The experimental budget on this application were tightly constrained. The
speedups achieved and the budget utilization of our approach on this setting
motivated a more comprehensive performance evaluation. We chose the /Search
Problems in Automatic Performance Tuning/
(SPAPT)\nbsp{}\cite{balaprakash2012spapt} benchmark for this evaluation, where
our approach was able to find speedups of over 50$\times$ for some SPAPT
applications, finding speedups better than random sampling in some scenarios.
Despite using generic performance models for every SPAPT application, our
approach was able to significantly decrease the budget used to find performance
improvements.

The rest of this paper is organized as follows. Section [[Background]] presents
related work on source-to-source transformation, which is the main optimization
target in SPAPT problems, on autotuning systems and on search space exploration
strategies. Section [[Applying Design of Experiments to Autotuning]] presents a
detailed description of the implementation of our approach and its background.
It discusses the Design of Experiments concepts we incorporate, and the ANOVA
and linear regression algorithms we use in analysis steps. Section [[Performance
Evaluations]] presents our results with the GPU Laplacian Kernel and the SPAPT
benchmark. Section [[Conclusion]] discusses our conclusions and future work.
* Background
** Source-to-source Transformation
** Autotuning
Rice's conceptual framework\nbsp{}\cite{rice1976algorithm} formed the foundation
of autotuners in various problem domains. In 1997, the PHiPAC
system\nbsp{}\cite{bilmes1997optimizing} used code generators and search scripts
to automatically generate high performance code for matrix multiplication. Since
then, systems tackled different domains with a diversity of strategies. Dongarra
/et al./\nbsp{}\cite{dongarra1998automatically} introduced the ATLAS
project, that optimizes dense matrix multiplication routines. The
OSKI\nbsp{}\cite{vuduc2005oski} library provides automatically tuned kernels for
sparse matrices. The FFTW\nbsp{}\cite{frigo1998fftw} library provides tuned C
subroutines for computing the Discrete Fourier Transform.
Periscope\nbsp{}\cite{gerndt2010automatic} is a distributed online autotuner for
parallel systems and single-node performance. In an effort to provide a common
representation of multiple parallel programming models, the INSIEME compiler
project\nbsp{}\cite{jordan2012multi} implements abstractions for OpenMP, MPI and
OpenCL, and generates optimized parallel code for heterogeneous multi-core
architectures.

Some systems provide generic tools that enable the implementation of autotuners
in various domains. PetaBricks\nbsp{}\cite{ansel2009petabricks} is a language,
compiler and autotuner that introduces abstractions that enable programmers to
define multiple algorithms for the same problem. The ParamILS
framework\nbsp{}\cite{hutter2009paramils} applies stochastic local search methods for
algorithm configuration and parameter tuning. The OpenTuner
framework\nbsp{}\cite{ansel2014opentuner} provides ensembles of techniques that search
spaces of program configurations.
** Search Space Exploration Strategies
* Applying Design of Experiments to Autotuning
An /experimental design/ is a plan for executing a series of experiments
whose objective is to identify the relationships between /factors/ and
/responses/. While factors and responses can refer to different concrete
entities in other domains, in computer experiments factors can be configuration
parameters for algorithms and compilers, for example, and responses can be the
execution time or memory consumption of a program.

Experimental designs can be used with various objectives, from identifying the
most important factors to building an analytical model for the response. The
field of Design of Experiments encompasses the mathematical formalization of
the construction of experimental designs. More practical works in the field
present algorithms to generate designs with different objectives and
restrictions.

One of the first detailed descriptions and mathematical treatment of Design of
Experiments was presented by Ronald Fisher\nbsp{}\cite{fisher1937design} in his
1937 book /The Design of Experiments/, where he discussed principles of
experimentation, latin square sampling and factorial designs. Later books such
as the ones from Jain\nbsp{}\cite{bukh1992art},
Montgomery\nbsp{}\cite{montgomery2017design} and Box /et
al./\nbsp{}\cite{box2005statistics} present comprehensive and detailed
foundations.
** Design Construction Techniques
Our application of Design of Experiments requires support for factors of
different types and number of possible values, such as binary flags, integer
and floating point numerical values and unordered enumerations of abstract
values. We also need designs that minimize the number of experiments needed for
identifying the most relevant factors in a given problem, since at this moment
we are not interesting in a precise analytical model.

The design construction techniques that fit these requirements are limited.  In
the /2-level screening with random level sampling/ technique, factors
with more than two unordered levels are sampled at two random levels. This
enables using small design such as the Plackett-Burman screening design.
Advantages are the small design size and good estimation capability for main
effects. Disadvantages are the incapability of estimating interactions, but
mainly the lack of information regarding the response for levels not selected
in the initial screening.

In /contractive replacement/, an initial 2-Level design is used to
generate mixed-level designs by re-encoding columns into a new single column
representing a multi-level factor. The contractive replacement of
Addelman-Kempthorne is a strategy of this kind.  Advantages are also small
design sizes and good estimation capability of main effects. Additionally, the
contractive replacement technique keeps orthogonality of designs.
Disadvantages are the requirements on the initial designs. Not all 2-Level
designs can be contracted with those methods if orthogonality is desired.

The /direct generation/ algorithm presented by Grömping and
Fontana\nbsp{}\cite{ulrike2018algorithm} enables the generation of multi-level
designs with the Generalized Minimum Aberration optimality criterion by solving
mixed integer problems. Advantages are the direct generation of multi-level
designs and the optimality criteria. Disadvantages are the use of proprietary
MIP solvers and the limitations on the size and shape of the designs that can be
generated.
** D-Optimal Designs
The best candidate we have found so far are /D-Optimal/ designs. Considering
that we are going to analyse the results of an experiments plan, the
/D-Efficiency/ of a design is inversely proportional to the /geometric mean/ of
the /eigenvalues/ of the plan's /covariance matrix/. A D-Optimal design has the
best D-Efficiency. Our current approach is based on D-Optimal designs.
** ANOVA
** The DLMT Strategy
#+BEGIN_CENTER
#+ATTR_LATEX: :width .8\columnwidth
#+ATTR_ORG: :width 400
[[./img/doe_anova_strategy.eps]]
#+END_CENTER

* Performance Evaluations
** Example on a GPU Laplacian Kernel
** Results on the SPAPT Benchmark
*** Experimental Methodology
* Conclusion
* Acknowledgment
:PROPERTIES:
:UNNUMBERED: t
:END:
#+LATEX: \bibliographystyle{IEEEtran}
#+LATEX: \bibliography{references}
